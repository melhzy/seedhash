row.names = FALSE)
}
# Save R object
saveRDS(ml_matrices, file.path(output_dir, "ml_matrices.rds"))
message(paste("Output saved to:", output_dir))
}
# Generate summary report
if (!is.null(ml_matrices)) {
message("\n=== Final Summary ===")
if (!is.null(ml_matrices$paired)) {
message(paste("Paired samples:", nrow(ml_matrices$paired$clinical)))
message(paste("Taxa:", length(ml_matrices$paired$taxa_names)))
}
message("\nPipeline completed successfully!")
}
return(ml_matrices)
}
# Execute the pipeline
ml_data <- run_microbiome_pipeline(save_output = TRUE)
# Optional: Quick visualization of the data
if (!is.null(ml_data) && !is.null(ml_data$paired)) {
# Check correlation between gut and oral microbiomes
gut_oral_cors <- sapply(1:ncol(ml_data$paired$gut_clr), function(i) {
cor(ml_data$paired$gut_clr[, i],
ml_data$paired$oral_clr[, i],
use = "complete.obs")
})
message("\n=== Gut-Oral Correlations ===")
message(paste("Mean correlation:", round(mean(gut_oral_cors, na.rm = TRUE), 3)))
message(paste("Median correlation:", round(median(gut_oral_cors, na.rm = TRUE), 3)))
# Find most correlated taxa
top_correlated <- order(abs(gut_oral_cors), decreasing = TRUE)[1:10]
message("\nTop 10 correlated taxa between gut and oral sites:")
for (i in top_correlated) {
message(paste("  ", ml_data$paired$taxa_names[i],
"- Correlation:", round(gut_oral_cors[i], 3)))
}
}
# Clear environment and load libraries
rm(list = ls())
library(curatedMetagenomicData)
library(dplyr)
library(tidyr)
# Step 1: Test basic functionality
test_cmd_access <- function() {
message("\n=== Testing curatedMetagenomicData Access ===")
# Test 1: Check if package is loaded
if (!requireNamespace("curatedMetagenomicData", quietly = TRUE)) {
message("ERROR: curatedMetagenomicData not installed properly")
message("Install with: BiocManager::install('curatedMetagenomicData')")
return(FALSE)
}
message("
✓ Package loaded successfully")
# Test 2: Try to access sample metadata
message("\nTesting metadata access...")
metadata_test <- tryCatch({
# Method 1: Direct access
sampleMetadata
}, error = function(e) {
message("  Method 1 failed, trying alternative...")
NULL
})
if (is.null(metadata_test)) {
# Method 2: Package namespace
metadata_test <- tryCatch({
curatedMetagenomicData::sampleMetadata
}, error = function(e) {
message("  Method 2 failed, trying another alternative...")
NULL
})
}
if (is.null(metadata_test)) {
# Method 3: Load explicitly
metadata_test <- tryCatch({
data("sampleMetadata", package = "curatedMetagenomicData")
get("sampleMetadata")
}, error = function(e) {
message("  Method 3 failed")
NULL
})
}
if (!is.null(metadata_test)) {
message(paste("
✓ Metadata accessed:", nrow(metadata_test), "samples"))
return(TRUE)
} else {
message("
✗ Could not access metadata")
return(FALSE)
}
}
# Run the test
access_ok <- test_cmd_access()
# Simplified function to get any available data
get_any_cmd_data <- function() {
message("\n=== Attempting to retrieve ANY available dataset ===")
# List of studies to try (ordered by likelihood of success)
test_studies <- c(
"HMP_2012.relative_abundance",
"ZellerG_2014.relative_abundance",
"YuJ_2015.relative_abundance",
"QinN_2014.relative_abundance",
"NielsenHB_2014.relative_abundance"
)
for (study_query in test_studies) {
message(paste("\nTrying:", study_query))
result <- tryCatch({
# Try with minimal parameters
data_list <- curatedMetagenomicData(
study_query,
dryrun = FALSE
)
if (length(data_list) > 0) {
message("
✓ Success!")
# Extract the data
se_obj <- data_list[[1]]
# Get basic info
n_samples <- ncol(se_obj)
n_features <- nrow(se_obj)
message(paste("    Samples:", n_samples))
message(paste("    Features:", n_features))
return(list(
study = gsub("\\..*", "", study_query),
se_object = se_obj,
success = TRUE
))
}
NULL
}, error = function(e) {
message(paste("
✗ Failed:", e$message))
NULL
})
if (!is.null(result)) return(result)
}
message("\nCould not retrieve any datasets")
return(NULL)
}
# Try to get data
any_data <- get_any_cmd_data()
any_data
# Clear environment
rm(list = ls())
# Load required libraries
library(BiocManager)
library(curatedMetagenomicData)
library(TreeSummarizedExperiment)
library(SummarizedExperiment)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
# Set options for better display
options(stringsAsFactors = FALSE)
options(width = 120)
# Function to verify CMD installation and access
verify_cmd_installation <- function() {
cat("========================================\n")
cat("Verifying curatedMetagenomicData Setup\n")
cat("========================================\n\n")
# Check package version
pkg_version <- packageVersion("curatedMetagenomicData")
cat("Package version:", as.character(pkg_version), "\n")
# Check if metadata is accessible
tryCatch({
# Load metadata
metadata <- sampleMetadata
cat("
✓ Metadata accessible\n")
cat("  Total samples:", nrow(metadata), "\n")
cat("  Total studies:", length(unique(metadata$study_name)), "\n\n")
# Show body site distribution
if ("body_site" %in% names(metadata)) {
cat("Body site distribution:\n")
body_sites <- table(metadata$body_site)
top_sites <- sort(body_sites, decreasing = TRUE)[1:min(10, length(body_sites))]
for(site in names(top_sites)) {
cat(sprintf("  %-30s: %d\n", site, top_sites[site]))
}
}
return(TRUE)
}, error = function(e) {
cat("
✗ Error accessing metadata:", e$message, "\n")
cat("Attempting alternative loading method...\n")
# Try alternative
tryCatch({
data("sampleMetadata", package = "curatedMetagenomicData")
cat("
✓ Metadata loaded via data() function\n")
return(TRUE)
}, error = function(e2) {
cat("
✗ Failed to load metadata\n")
return(FALSE)
})
})
}
# Run verification
cmd_ready <- verify_cmd_installation()
cmd_ready
# Function to get and analyze available studies
get_available_studies <- function() {
cat("\n========================================\n")
cat("Analyzing Available Studies\n")
cat("========================================\n\n")
# Load metadata
metadata <- sampleMetadata
# Get unique studies with sample counts
study_summary <- metadata %>%
group_by(study_name) %>%
summarise(
n_samples = n(),
body_sites = paste(unique(body_site), collapse = ", "),
n_body_sites = n_distinct(body_site),
diseases = paste(unique(disease), collapse = ", "),
.groups = "drop"
) %>%
arrange(desc(n_samples))
# Studies with gut and oral samples
gut_oral_studies <- metadata %>%
mutate(
has_gut = body_site %in% c("stool", "feces"),
has_oral = body_site %in% c("oral_cavity", "saliva", "tongue_dorsum",
"buccal_mucosa", "supragingival_plaque",
"subgingival_plaque")
) %>%
group_by(study_name) %>%
summarise(
has_both = any(has_gut) & any(has_oral),
n_gut = sum(has_gut),
n_oral = sum(has_oral),
.groups = "drop"
) %>%
filter(has_both)
cat("Total studies:", nrow(study_summary), "\n")
cat("Studies with both gut and oral samples:", nrow(gut_oral_studies), "\n\n")
cat("Top 10 studies by sample size:\n")
print(head(study_summary[, c("study_name", "n_samples", "n_body_sites")], 10))
return(list(
all_studies = study_summary,
gut_oral_studies = gut_oral_studies
))
}
# Get available studies
available_studies <- get_available_studies()
# Function to load a single study safely
load_single_study <- function(study_name,
data_type = "relative_abundance",
max_retries = 3) {
cat("\n----------------------------------------\n")
cat("Loading:", study_name, "\n")
cat("----------------------------------------\n")
# Build query
query <- paste0(study_name, ".", data_type)
for (attempt in 1:max_retries) {
cat("Attempt", attempt, "of", max_retries, "...\n")
result <- tryCatch({
# Load data
tse_list <- curatedMetagenomicData(
query,
dryrun = FALSE,
counts = FALSE
)
if (length(tse_list) == 0) {
cat("  No data returned\n")
return(NULL)
}
# Extract the TreeSummarizedExperiment object
tse <- tse_list[[1]]
# Extract components
sample_meta <- as.data.frame(colData(tse))
abundance_matrix <- as.matrix(assay(tse))
taxa_info <- as.data.frame(rowData(tse))
# Summary statistics
cat("
✓ Successfully loaded!\n")
cat("  Samples:", ncol(abundance_matrix), "\n")
cat("  Taxa:", nrow(abundance_matrix), "\n")
if ("body_site" %in% names(sample_meta)) {
cat("  Body sites:", paste(unique(sample_meta$body_site), collapse = ", "), "\n")
}
return(list(
study_name = study_name,
metadata = sample_meta,
abundance = abundance_matrix,
taxa_info = taxa_info,
tse_object = tse,
success = TRUE
))
}, error = function(e) {
cat("  Error:", e$message, "\n")
if (attempt < max_retries) {
cat("  Waiting 2 seconds before retry...\n")
Sys.sleep(2)
}
return(NULL)
})
if (!is.null(result)) return(result)
}
cat("
✗ Failed to load after", max_retries, "attempts\n")
return(list(success = FALSE, study_name = study_name))
}
# Function to load multiple studies one by one
load_studies_sequentially <- function(study_list = NULL,
max_studies = 5,
save_progress = TRUE) {
cat("\n========================================\n")
cat("Loading Studies Sequentially\n")
cat("========================================\n\n")
# If no study list provided, use default priority list
if (is.null(study_list)) {
study_list <- c(
"HMP_2012",           # Human Microbiome Project
"HMP_2019_ibdmdb",    # HMP2 IBD
"ZellerG_2014",       # Colorectal cancer
"YuJ_2015",           # Colorectal cancer
"QinN_2014",          # Liver cirrhosis
"NielsenHB_2014",     # IBD
"QinJ_2012",          # Type 2 diabetes
"KarlssonFH_2013",    # Type 2 diabetes
"LiJ_2017",           # Hypertension
"WirbelJ_2018"        # Multiple diseases including PD
)
}
# Limit number of studies
study_list <- study_list[1:min(length(study_list), max_studies)]
loaded_studies <- list()
failed_studies <- character()
for (i in seq_along(study_list)) {
study_name <- study_list[i]
cat(sprintf("\n[%d/%d] Processing %s\n", i, length(study_list), study_name))
# Load the study
study_data <- load_single_study(study_name)
if (!is.null(study_data) && isTRUE(study_data$success)) {
loaded_studies[[study_name]] <- study_data
# Save progress if requested
if (save_progress) {
saveRDS(study_data,
file = paste0("study_", study_name, "_", Sys.Date(), ".rds"))
cat("  Saved to:", paste0("study_", study_name, "_", Sys.Date(), ".rds"), "\n")
}
} else {
failed_studies <- c(failed_studies, study_name)
}
# Brief pause between studies
if (i < length(study_list)) {
cat("\nWaiting 3 seconds before next study...\n")
Sys.sleep(3)
}
}
# Summary
cat("\n========================================\n")
cat("Loading Complete\n")
cat("========================================\n")
cat("Successfully loaded:", length(loaded_studies), "studies\n")
if (length(failed_studies) > 0) {
cat("Failed studies:", paste(failed_studies, collapse = ", "), "\n")
}
return(loaded_studies)
}
# Load first 3 studies as a test
loaded_data <- load_studies_sequentially(max_studies = 3, save_progress = TRUE)
# Function to extract gut-oral paired samples from loaded studies
extract_gut_oral_pairs <- function(loaded_studies) {
cat("\n========================================\n")
cat("Extracting Gut-Oral Paired Samples\n")
cat("========================================\n\n")
all_paired_samples <- list()
for (study_name in names(loaded_studies)) {
study_data <- loaded_studies[[study_name]]
if (!study_data$success) next
metadata <- study_data$metadata
# Check if study has both gut and oral samples
if (!"body_site" %in% names(metadata)) {
cat(study_name, ": No body_site information\n")
next
}
# Categorize samples
metadata$site_category <- case_when(
metadata$body_site %in% c("stool", "feces") ~ "gut",
metadata$body_site %in% c("oral_cavity", "saliva", "tongue_dorsum",
"buccal_mucosa", "supragingival_plaque",
"subgingival_plaque") ~ "oral",
TRUE ~ "other"
)
# Find subjects with both gut and oral samples
if ("subject_id" %in% names(metadata)) {
paired_subjects <- metadata %>%
group_by(subject_id) %>%
summarise(
has_gut = "gut" %in% site_category,
has_oral = "oral" %in% site_category,
n_samples = n(),
.groups = "drop"
) %>%
filter(has_gut & has_oral)
if (nrow(paired_subjects) > 0) {
cat(study_name, ": Found", nrow(paired_subjects), "subjects with paired samples\n")
# Extract paired data
for (subj in paired_subjects$subject_id) {
subj_meta <- metadata[metadata$subject_id == subj, ]
gut_samples <- rownames(subj_meta)[subj_meta$site_category == "gut"]
oral_samples <- rownames(subj_meta)[subj_meta$site_category == "oral"]
if (length(gut_samples) > 0 && length(oral_samples) > 0) {
all_paired_samples[[paste0(study_name, "_", subj)]] <- list(
study = study_name,
subject_id = subj,
gut_samples = gut_samples,
oral_samples = oral_samples,
metadata = subj_meta
)
}
}
} else {
cat(study_name, ": No paired samples found\n")
}
} else {
cat(study_name, ": No subject_id information\n")
}
}
cat("\nTotal paired samples across all studies:", length(all_paired_samples), "\n")
return(all_paired_samples)
}
# Extract paired samples
paired_samples <- extract_gut_oral_pairs(loaded_data)
paired_samples
install.packages("languageserver")
q()
cat("=== seedhash CRAN Submission Preparation ===\n\n")
# Quick Start Script for CRAN Submission
# Run this script to prepare seedhash package for CRAN submission
cat("=== seedhash CRAN Submission Preparation ===\n\n")
# Set working directory to package root
setwd("d:/Github/seedhash/R")
cat("Step 1: Installing required packages...\n")
required_packages <- c("devtools", "roxygen2", "rcmdcheck", "rhub", "desc")
for (pkg in required_packages) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg)
}
}
cat("\nStep 2: Checking DESCRIPTION file...\n")
tryCatch({
desc::desc_validate()
cat("✓ DESCRIPTION is valid\n")
}, error = function(e) {
cat("✗ DESCRIPTION has issues:", e$message, "\n")
})
cat("\nStep 3: Updating documentation...\n")
tryCatch({
devtools::document()
cat("✓ Documentation updated\n")
}, error = function(e) {
cat("✗ Documentation error:", e$message, "\n")
})
cat("\nStep 4: Installing package locally...\n")
tryCatch({
devtools::install()
cat("✓ Package installed locally\n")
}, error = function(e) {
cat("✗ Installation error:", e$message, "\n")
})
cat("\nStep 5: Running R CMD check...\n")
cat("(This may take a few minutes...)\n")
check_results <- devtools::check()
cat("\nCheck Results Summary:\n")
cat("Errors:  ", length(check_results$errors), "\n")
cat("Warnings:", length(check_results$warnings), "\n")
cat("Notes:   ", length(check_results$notes), "\n")
if (length(check_results$errors) > 0) {
cat("\n✗ ERRORS found - must fix before submission:\n")
print(check_results$errors)
}
if (length(check_results$warnings) > 0) {
cat("\n⚠ WARNINGS found - should fix before submission:\n")
print(check_results$warnings)
}
if (length(check_results$notes) > 0) {
cat("\n⚠ NOTES found - review before submission:\n")
print(check_results$notes)
}
cat("\n=== Pre-Submission Checklist ===\n\n")
cat("Manual checks needed:\n")
cat("[ ] Updated email address in DESCRIPTION (replace your.email@example.com)\n")
cat("[ ] LICENSE file exists and is correct\n")
cat("[ ] NEWS.md is up to date\n")
cat("[ ] cran-comments.md reflects actual test results\n")
cat("[ ] README.md is complete\n")
cat("[ ] All examples run without errors\n")
cat("[ ] Package passes R CMD check with 0 errors, 0 warnings, 0 notes\n\n")
if (length(check_results$errors) == 0 &&
length(check_results$warnings) == 0 &&
length(check_results$notes) == 0) {
cat("✓ Package is ready for additional platform checks!\n\n")
cat("Next steps:\n")
cat("1. Run platform checks:\n")
cat("   devtools::check_win_devel()\n")
cat("   devtools::check_win_release()\n")
cat("   rhub::check_for_cran()\n\n")
cat("2. Build package:\n")
cat("   devtools::build()\n\n")
cat("3. Submit to CRAN:\n")
cat("   https://cran.r-project.org/submit.html\n\n")
} else {
cat("✗ Please fix all errors, warnings, and notes before proceeding.\n")
cat("Review the output above and make necessary corrections.\n\n")
}
cat("For detailed instructions, see: CRAN_SUBMISSION.md\n")
